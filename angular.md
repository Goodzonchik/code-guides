# Angular

#### 1. Называйте экземпляры сервисов также как и сервисы, только в `camelCase`.

```ts
// плохо
link = new LinkService();

// хорошо
linkService = new LinkService();
```

#### 2. Добавляйте в конце `$` для observable.

**Почему?** Именование будет согласно документации `Angular`. Также улучшится читаемость за счет понимания типа сущности по ее имени.

#### 3. Делайте текстовый комментарий для каждого поля `@Input()`/`@Output()`.

#### 4. Выносите `getter` и `setter` в отдельный метод у `@Input()` если он содержит больше 3-х строк.

#### 5. Делатяйте комментарий с названием компонента по постановке и ссылкой на постановку перед компонентом.

#### 6. Описывайте значения по умолчаниюм соответствующие их отображению для формы .

Нужно учитывать данные, которые отображаются в поле: пустая строка, boolean, массив и т.д. При очистке фильтров, можно прировнять значения формы

#### 7. Используйте функцию `trackBy` для предотвращения лишних перерисовок, если таблица динамически изменяется на форме, а не полностью перезаписывается.

#### 8. Используйте `alias`-ы путей для `@Shared`, `@Core`, `@Utils`.

#### 9. Не пишите в `Pipe` публичных методов, кроме `transform()`.

#### 10. Выносите стили компонента в отдельный файл.

#### 11. Шаблон компонента можно писать в .ts-файле, если он занимает не больше 3-х строк, или один компонент с набором `@Input()`/`@Output()` полей.

```html
<!-- Допускается использование шаблона больше 3-х строк, если это один тег с набором атрибутов -->
<some-component
    [arg1]="value1"
    [arg2]="value2"
    [arg3]="value3"
    [arg4]="value4"
>
<some-component>
```

#### 12. Оборачивайте каждый компонент в блок-обертку.

**Почему?** Потенциально может привести к проблемам верстки, если настроен какой-нибудь сдвиг по тегу, который повлияет на первый тег.

```html
<!-- плохо -->
<div>1</div>
<div>2</div>

<!-- хорошо -->
<div>
  <div>1</div>
  <div>2</div>
</div>
```

#### 13. Используйте в `Angular` для доступа к полям формы метод `form.get(‘controlName’)`.

**Почему?** Свойство `controls` используется для доступа к полям, с целью итеративных операций, например: генерация формы в цикле.

#### 14. Указывайте порядок `html-атрибутов` в определенном порядке.

- `Html-атрибуты`.
- Атрибуты `Angular` для настройки видимости (`ngIf`, `hidden` и т.д.).
- Атрибуты стиля`ngClass`/`ngStyle`.
- `@Input()`.
- `@Output()`.

```html
<component
    class="some-class"
    *ngIf="expression"
    [ngClass]="{'other-class': otherExpression}"
    [data]="data"
    (onChange)="onChange($event)"
    (onValidation)="onValidation($event)"
></component>
```

#### 15. Называйте сервис (компонент/класс) для постепенной замены старого сервиса c суффиксом New.

```ts
/* плохо */
SomeEntity2Service //использование цифр в наименовании не очень хорошая практика.
NewSomeEntityService //хороший вариант, но в каталоге файлов будет далеко располагаться от оригинального сервиса.

/* хорошо */
SomeEntityNewService
```

#### 16. Вынестиnте код из `Pipe` функцию в `Utils`.

Импортируйте функцию в `Pipe` и в сервисы и компоненты при необходимости.

**Почему?** Отделяется логика `Angular` от логики `JS/TS`. Не требует провайдинга `Pipe` в компонент или сервис. Код становиться чище.

# Архитектура проекта

1. Делаем общий сервис, который хранит в себе начальную сущность или модель на ее основе, текущую модель, методы для работы с моделью. Методы для работы с бэкендом (загрузить, сохранить и т.д.).
2. Загружаем сущность в сервис. Если работаем с сущностью, то сохраняем в поле, которое в дальнейшем не редактируется. Если работаем с модифицированной моделью, то на основе загруженной сущности делаем модель и сохраняем в неизменяемое поле.
3. Для каждого компонента сущности делаем сервис, который ответственный за логику и работу с данными.
4. Если сущность простая (из одной формы, например, запись из справочника), то делаем все в одном сервисе.
5. Если сущность состоит из нескольких подсущностей, то создается общий сервис для данных. Для сложных действий создаются отдельные сервисы (валидация, перемещение сущности по статусам и др.).
6. Главный компонент подписывается на модель, в остальные компоненты данные спускаются через `@Input()` или подписка на модель при необходимости.
7. Для изменения данных – дочерние компоненты обращаются к сервису и вызывают метод изменения модели.
8. Сервисы провайдятся в компоненты или корень приложения.
9. `ModifyRequest` - класс, а не интерфейс. Заполняем данные через конструктор.

```ts
// инициализация при добавлении
this.modifyRequest = new ModifyRequestEntity()

// инициализация при редактировании
this.modifyRequest = new ModifyRequestEntity(entityFromResponse)
```
 
10. В компоненте получаем `modifyRequest` пишем его в `this.form.patchValue()`. В подписке на изменения формы проверяем, через `deepEqual`, налиличе изменениц изменения, то отправляем данные в "главный сервис".
11. Валидация простых сущностей (1 сущность – один компонент-форма) – можно делать валидацию на уровне формы компонента и отправлять флаг `valid` в глобальный сервис сущности.
12. Для составных сущностей (1 сущность – несколько компонент-форм) – сделать обработку валидации в отдельном сервисе валидации для сущности, в нем же разрешать проблемы с зависимостями данных одной формы от другой при валидации. Сервис-валидации будет отправлять сам флаг `valid` в главный сервис, а также будет возвращать коды/текстовки ошибок для компонентов (единым объектом или строками).

## Что дает данная архитектура:

1. Единый источник истины – «главный сервис» сущности.
2. Компоненты лишается логики и отвечает за отрисовку данных.
3. Сокращаяется размер кода компонентов.
4. Логика будет отделена от представления. Позволит гораздо проще проводить редизайн.
5. Возможности использовать OnPush-стратегию для снижения количества перерисовок.
6. Легче будет использовать библиотеки для стейт-менеджмента, или же сделать логирование самописной истории изменений для отладки.
7. Легче тестировать компоненты, передавая в них модели.
8. Легче тестировать бизнес-логику, так как она сформированна в одном месте. Также сервисы легче тестировать, чем компоненты.

# Порядок полей в файле

```ts
/* различные импорты */
import {Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {Observable, Subject} from 'rxjs';

/* небольшие enum, interface, class, const и подобное, что не обязательно выносить в отдельный файл */
enum mode {
	create,
	edit,
	view
}

/* Подпись компонента, если есть возможность*/
/** SOME_COMPONENT Название компонента, если оно есть в постановке */
/** Также можно добавлять ссылку на постановку, если она одна */

/* Декоратор компонента */
/* Обязательно использовать selector, с ним легче вести отладку кода*/
@Component({
	selector: 'component-selector',
    templateUrl: './some-component.component.html',
    styleUrls: ['./some-component.component.scss'],
    providers: [SomeService]
})
export class SbaAgreementCardComponent implements OnInit, OnDestroy {
	/*Первыми идут ViewChild*/
    @ViewChild('table', {static: false}) table: TableComponent;
    @ViewChild('tableFilter', {static: false}) tableFilter: TableFilterComponent;

	/* INPUT - параметры компонента*/
	/* Сперва идут простые INPUT*/
	@INPUT() organization: Organization;
	...

	/* Через строку отделены INPUT, которые имеют get и set*/
	@INPUT() set viewMode(value: boolean) {
        this.innerViewMode = this.accountTabViewMode = value;
    }

    get viewMode(): boolean {
        return this.innerViewMode;
    }

	/* OUTPUT - параметры компонента*/
	@Output() onChange: EventEmitter<someModel> = new EventEmitter<someModel>();
    @Output() onValidation: EventEmitter<boolean> = new EventEmitter<boolean>();
	...

	/*Публичные поля компонента*/
    title: string = 'Заголовок компонента';
    showErrors = false;
    hasChanges = false;
    /*Сперва идут простые поля, в конце указываются поля, которые не помещаются в одну строку (объекты или несколько типов через "или")*/
    someMode = {
        field1: false,
        field2: false,
        field3: false,
    }
    ...

	/*Публичные readonly поля компонента*/
    readonly readonlyData = ReadonlyData;
	...

	/*Приватные поля компонента*/
    private onDestroy$ = new Subject();
    private dialogRef: DynamicDialogRef;
	...

    /*Приватные readonly поля компонента*/
	private readonly someField: '';

	/*Конструктор класса */
    constructor(
		/* сперва идут публичные аргументы*/
        readonly someServiceService: SomeServiceService,
		/* в конце идут приватные аргументы*/
        private readonly preloaderService: PreloaderService
    ) {}

    /*getter-ы*/
    get organizationNameControl(){
        ...
    }

    /*setter-ы*/
    set organizationNameControl(){
        ...
    }

	/*ngOnInit и  ngAfterViewInit - первые публичные методы компонента, после конструктора*/
    ngOnInit() {
    ...
    }

    ngAfterViewInit() {
    ...
    }

	/*Остальные публичные методы компонента*/

	edit(){
	...
	}

	save(){
	...
	}

	/*Последними публичными методами идут ngOnDestroy и canDeactivated*/
    ngOnDestroy(): void {
    ...
    }

	/*Все protected поля*/
    protected checkingValidation() {
    ...
    }

	/*Все публичные поля*/
    private checkingValidation() {
    ...
    }
}

```
