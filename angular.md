# Angular

#### 1. Экземпляры сервисов называть также как и сервисы, только в camelCase

```ts
// плохо
link = new LinkService();

// хорошо
linkService = new LinkService();
```

#### 2. Для observable добавлять в конце `$`.

**Почему?** Именование будет согласно документации Angular. Также улучшится читаемость за счет понимания типа сущности по ее имени.

#### 3. Делать текстовый комментарий для каждого поля `@Input()`/`@Output()`

#### 4. Если `@Input()` имеет getter и setter, то если там больше 3 строк, то стоит выносить его в функцию/метод

#### 5. Делать комментарий с названием компонента по постановке и ссылкой на постановку перед компонентом

#### 6. Формы должны иметь значения по-умолчанию соответствующие их отображению. Пустая строка, false, пустой массив и т.д. При очистке фильтров, можно прировнять значения формы

#### 7. Использовать функцию trackBy для предотвращения лишних перерисовок, если таблица динамически изменяется

#### 8. Использовать alias-ы путей для @shared, @core, @Utils.

#### 9. В Pipe не должно быть публичных методов, кроме transform.

#### 10. Стили компонента всегда выносить в другой файл

#### 11. Шаблон компонента можно писать в .ts-файле, если он занимает не больше 3-х строк, или один компонент с набором @Input()/@Output полей

#### 12. Каждый компонент должен иметь блок-обертку.

**Почему?** Потенциально может привести к проблемам верстки, если настроен какой-нибудь сдвиг по тегу, который повлияет на первый тег.

```html
<!-- плохо -->
<div>1</div>
<div>2</div>

<!-- хорошо -->
<div>
  <div>1</div>
  <div>2</div>
</div>
```

#### 13. В `Angular` для доступа к полям формы используется метод `form.get(‘controlName’)`.

#### 14. В шаблоне сперва указываются атрибуты html, потом атрибуты angular для настройки видимости, потом @Input(), потом @Output().

**Почему?** Свойство `controls` используется для доступа к полям, с целью итеративных операций, например: генерация формы в цикле

# Архитектура проекта

1. Делаем общий сервис, который хранит в себе начальную сущность/модифицированную модель, текущую модель, методы для работы с моделью. Методы для работы с бэком (загрузить, сохранить).
2. Загружаем сущность в сервис.
   a. Если работает с сущностью, то сохраняем в поле, которое не изменяемое
   b. Если работаем с модифицированной моделью, то на основе загруженной сущности делаем модель и сохраняем в неизменяемое поле
3. Для каждого компонента сущности делаем сервис, который отечественный за логику и работу с данными
4. Если сущность простая (из одной формы; например запись из справочника), то делаем все в одном сервисе.
5. Если сущность состоит из нескольких подсущностей, то создается общий сервис для данных. Возможно отдельное вынесение сервиса для валидации подсущностей для различных состояний.
6. Главный компонент подписывается на модель, в остальные компоненты данные спускаются через @Input().
7. Для изменения данных – дочерние компоненты обращаются к сервису и отправляют в него метод изменения модели.
8. Возможно выделение отдельного сервиса/сервисов под специфичные подзадачи (например, перемещение по статусам)
9. Сервисы провайдятся в компоненты или корень приложения.
10. ModifyRequest - класс, а не интерфейс. Заполняем данные через конструктор.
    a. При инициализации делаем так:
    this.modifyRequest = new ModifyRequestEntity() - для формирования пустой записи с информацией значений по умолчанию.
    b. передаём полученную с бэка запись
    this.modifyRequest = new ModifyRequestEntity(entityFromResponse)
11. В компоненте. Получаем modifyRequest пишем его в this.form.patchValue() И в подписке на изменения формы проверяем, через deepEqual, если есть изменения, то отправляем данные в главный сервис.
12. Валидация
    a. Для простых сущностей (1 сущность – один компонент-форма) – можно делать валидацию на уровне формы компонента и отправлять флаг valid в глобальный сервис сущности
    b. Для составных сущностей (1 сущность – несколько компонент-форм) – сделать обработку валидации в отдельном сервисе валидации для сущности, в нем же разрешать проблемы с зависимостями данных одной формы от другой при валидации. Сервис-валидации будет отправлять сам флаг valid в главный сервис, а также будет возвращать коды/текстовки ошибок для компонентов (единым объектом или строками).
13.

## Что позволит данная архитектура:

1. Единый источник истины – «главный сервис» сущности.
2. Компоненты почти полностью отвечают только за отрисовку, без логики
3. Код компонентов будет минимален
4. Логика будет отделена от представления. Позволит гораздо проще проводить редизайн.
5. Возможности использовать OnPush-стратегию – для снижения количества перерисовок
6. Легче будет использовать библиотеки для стейт-менеджмента, или же сделать логирование самописной истории изменений для отладки

# Порядок полей в файле

```ts
/* различные импорты */
import {Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {Observable, Subject} from 'rxjs';

/* небольшие enum, interface, class, const и подобное, что не обязательно выносить в отдельный файл */
enum mode {
	create,
	edit,
	view
}

/* Подпись компонента, если есть возможность*/
/** SOME_COMPONENT Название компонента, если оно есть в постановке */
/** Также можно добавлять ссылку на постановку, если она одна */

/* Декоратор компонента */
/* Обязательно использовать selector, с ним легче вести отладку кода*/
@Component({
	selector: 'component-selector',
    templateUrl: './some-component.component.html',
    styleUrls: ['./some-component.component.scss'],
    providers: [SomeService]
})
export class SbaAgreementCardComponent implements OnInit, OnDestroy {
	/*Первыми идут ViewChild*/
    @ViewChild('table', {static: false}) table: TableComponent;
    @ViewChild('tableFilter', {static: false}) tableFilter: TableFilterComponent;

	/* INPUT - параметры компонента*/
	/* Сперва идут простые INPUT*/
	@INPUT() organization: Organization;
	...

	/* Через строку отделены INPUT, которые имеют get и set*/
	@INPUT() set viewMode(value: boolean) {
        this.innerViewMode = this.accountTabViewMode = value;
    }

    get viewMode(): boolean {
        return this.innerViewMode;
    }

	/* OUTPUT - параметры компонента*/
	@Output() onChange: EventEmitter<someModel> = new EventEmitter<someModel>();
    @Output() onValidation: EventEmitter<boolean> = new EventEmitter<boolean>();
	...

	/*Публичные поля компонента*/
    title: string = 'Заголовок компонента';
    showErrors = false;
    hasChanges = false;
    /*Сперва идут простые поля, в конце указываются поля, которые не помещаются в одну строку (объекты или несколько типов через "или")*/
    someMode = {
        field1: false,
        field2: false,
        field3: false,
    }
    ...

	/*Публичные readonly поля компонента*/
    readonly readonlyData = ReadonlyData;
	...

	/*Приватные поля компонента*/
    private onDestroy$ = new Subject();
    private dialogRef: DynamicDialogRef;
	...

    /*Приватные readonly поля компонента*/
	private readonly someField: '';

	/*Конструктор класса */
    constructor(
		/* сперва идут публичные аргументы*/
        readonly someServiceService: SomeServiceService,
		/* в конце идут приватные аргументы*/
        private readonly preloaderService: PreloaderService
    ) {}

    /*getter-ы*/
    get organizationNameControl(){
        ...
    }

    /*setter-ы*/
    set organizationNameControl(){
        ...
    }

	/*ngOnInit и  ngAfterViewInit - первые публичные методы компонента, после конструктора*/
    ngOnInit() {
    ...
    }

    ngAfterViewInit() {
    ...
    }

	/*Остальные публичные методы компонента*/

	edit(){
	...
	}

	save(){
	...
	}

	/*Последними публичными методами идут ngOnDestroy и canDeactivated*/
    ngOnDestroy(): void {
    ...
    }

	/*Все protected поля*/
    protected checkingValidation() {
    ...
    }

	/*Все публичные поля*/
    private checkingValidation() {
    ...
    }
}

```
