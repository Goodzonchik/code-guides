# Angular

1. Соглашения по именованию:

   1.1. Экземпляры сервисов называть также как и сервисы, только в camelCase
   someService = new SomeService();
   Поможет избежать путаницы в понимании того, с какой сущностью идет взаимодействие

   1.2. Для observable добавлять в конце `$`. Согласно неймингу ангуляра. Также поможет понимать, что есть observable, а что – нет.

2. Делать текстовый комментарий для каждого поля `@Input()`/`@Output()`

3. Если `@Input()` имеет getter и setter, то если там больше 3 строк, то стоит выносить его в функцию/метод

4. Делать комментарий с названием компонента по постановке и ссылкой на постановку

5. Формы должны иметь значения по-умолчанию соответствующие их отображению. Пустая строка, false, пустой массив и т.д. При очистке фильтров, можно прировнять значения формы к конфигурации формы.

# Архитектура проекта

1. Делаем общий сервис, который хранит в себе начальную сущность/модифицированную модель, текущую модель, методы для работы с моделью. Методы для работы с бэком (загрузить, сохранить).
2. Загружаем сущность в сервис.
   a. Если работает с сущностью, то сохраняем в поле, которое не изменяемое
   b. Если работаем с модифицированной моделью, то на основе загруженной сущности делаем модель и сохраняем в неизменяемое поле
3. Для каждого компонента сущности делаем сервис, который отечественный за логику и работу с данными
4. Если сущность простая (из одной формы; например запись из справочника), то делаем все в одном сервисе.
5. Если сущность состоит из нескольких подсущностей, то создается общий сервис для данных. Возможно отдельное вынесение сервиса для валидации подсущностей для различных состояний.
6. Главный компонент подписывается на модель, в остальные компоненты данные спускаются через @Input().
7. Для изменения данных – дочерние компоненты обращаются к сервису и отправляют в него метод изменения модели.
8. Возможно выделение отдельного сервиса/сервисов под специфичные подзадачи (например, перемещение по статусам)
9. Сервисы провайдятся в компоненты или корень приложения.
10. ModifyRequest - класс, а не интерфейс. Заполняем данные через конструктор.
    a. При инициализации делаем так:
    this.modifyRequest = new ModifyRequestEntity() - для формирования пустой записи с информацией значений по умолчанию.
    b. передаём полученную с бэка запись
    this.modifyRequest = new ModifyRequestEntity(entityFromResponse)
11. В компоненте. Получаем modifyRequest пишем его в this.form.patchValue() И в подписке на изменения формы проверяем, через deepEqual, если есть изменения, то отправляем данные в главный сервис.
12. Валидация
    a. Для простых сущностей (1 сущность – один компонент-форма) – можно делать валидацию на уровне формы компонента и отправлять флаг valid в глобальный сервис сущности
    b. Для составных сущностей (1 сущность – несколько компонент-форм) – сделать обработку валидации в отдельном сервисе валидации для сущности, в нем же разрешать проблемы с зависимостями данных одной формы от другой при валидации. Сервис-валидации будет отправлять сам флаг valid в главный сервис, а также будет возвращать коды/текстовки ошибок для компонентов (единым объектом или строками).
13.

## Что позволит данная архитектура:

1. Единый источник истины – «главный сервис» сущности.
2. Компоненты почти полностью отвечают только за отрисовку, без логики
3. Код компонентов будет минимален
4. Логика будет отделена от представления. Позволит гораздо проще проводить редизайн.
5. Возможности использовать OnPush-стратегию – для снижения количества перерисовок
6. Легче будет использовать библиотеки для стейт-менеджмента, или же сделать логирование самописной истории изменений для отладки
7.

# Порядок полей в файле

```ts
/* различные импорты */
import {Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {Observable, Subject} from 'rxjs';

/* небольшие enum, interface, class, const и подобное, что не обязательно выносить в отдельный файл */
enum mode {
	create,
	edit,
	view
}

/* Подпись компонента, если есть возможность*/
/** SOME_COMPONENT Название компонента, если оно есть в постановке */
/** Также можно добавлять ссылку на постановку, если она одна */

/* Декоратор компонента */
/* Обязательно использовать selector, с ним легче вести отладку кода*/
@Component({
	selector: 'component-selector',
    templateUrl: './some-component.component.html',
    styleUrls: ['./some-component.component.scss'],
    providers: [SomeService]
})
export class SbaAgreementCardComponent implements OnInit, OnDestroy {
	/*Первыми идут ViewChild*/
    @ViewChild('table', {static: false}) table: TableComponent;
    @ViewChild('tableFilter', {static: false}) tableFilter: TableFilterComponent;

	/* INPUT - параметры компонента*/
	/* Сперва идут простые INPUT*/
	@INPUT() organization: Organization;
	...

	/* Через строку отделены INPUT, которые имеют get и set*/
	@INPUT() set viewMode(value: boolean) {
        this.innerViewMode = this.accountTabViewMode = value;
    }

    get viewMode(): boolean {
        return this.innerViewMode;
    }

	/* OUTPUT - параметры компонента*/
	@Output() onChange: EventEmitter<someModel> = new EventEmitter<someModel>();
    @Output() onValidation: EventEmitter<boolean> = new EventEmitter<boolean>();
	...

	/*Публичные поля компонента*/
    title: string = 'Заголовок компонента';
    showErrors = false;
    hasChanges = false;
    /*Сперва идут простые поля, в конце указываются поля, которые не помещаются в одну строку (объекты или несколько типов через "или")*/
    someMode = {
        field1: false,
        field2: false,
        field3: false,
    }
    ...

	/*Публичные readonly поля компонента*/
    readonly readonlyData = ReadonlyData;
	...

	/*Приватные поля компонента*/
    private onDestroy$ = new Subject();
    private dialogRef: DynamicDialogRef;
	...

    /*Приватные readonly поля компонента*/
	private readonly someField: '';

	/*Конструктор класса */
    constructor(
		/* сперва идут публичные аргументы*/
        readonly someServiceService: SomeServiceService,
		/* в конце идут приватные аргументы*/
        private readonly preloaderService: PreloaderService
    ) {}

    /*getter-ы*/
    get organizationNameControl(){
        ...
    }

    /*setter-ы*/
    set organizationNameControl(){
        ...
    }

	/*ngOnInit и  ngAfterViewInit - первые публичные методы компонента, после конструктора*/
    ngOnInit() {
    ...
    }

    ngAfterViewInit() {
    ...
    }

	/*Остальные публичные методы компонента*/

	edit(){
	...
	}

	save(){
	...
	}

	/*Последними публичными методами идут ngOnDestroy и canDeactivated*/
    ngOnDestroy(): void {
    ...
    }

	/*Все protected поля*/
    protected checkingValidation() {
    ...
    }

	/*Все публичные поля*/
    private checkingValidation() {
    ...
    }
}

```
