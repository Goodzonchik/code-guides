# Angular

#### 1. Экземпляры сервисов называть также как и сервисы, только в `camelCase`.

```ts
// плохо
link = new LinkService();

// хорошо
linkService = new LinkService();
```

#### 2. Для observable добавлять в конце `$`.

**Почему?** Именование будет согласно документации `Angular`. Также улучшится читаемость за счет понимания типа сущности по ее имени.

#### 3. Делать текстовый комментарий для каждого поля `@Input()`/`@Output()`.

#### 4. Если `@Input()` имеет `getter` и `setter`, то если там больше 3 строк, то стоит выносить его в функцию/метод.

#### 5. Делать комментарий с названием компонента по постановке и ссылкой на постановку перед компонентом.

#### 6. Формы должны иметь значения по-умолчанию соответствующие их отображению.

Нужно учитывать данные, которые отображаются в поле: пустая строка, boolean, массив и т.д. При очистке фильтров, можно прировнять значения формы

#### 7. Использовать функцию `trackBy` для предотвращения лишних перерисовок, если таблица динамически изменяется на форме, а не полностью перезаписывается.

#### 8. Использовать `alias`-ы путей для `@Shared`, `@Core`, `@Utils`.

#### 9. В `Pipe` не должно быть публичных методов, кроме `transform()`.

#### 10. Стили компонента всегда выносить в отдельный файл.

#### 11. Шаблон компонента можно писать в .ts-файле, если он занимает не больше 3-х строк, или один компонент с набором `@Input()`/`@Output()` полей.

```html
<!-- Допускается использование шаблона больше 3-х строк, если это один тег с набором атрибутов -->
<some-component
    [arg1]="value1"
    [arg2]="value2"
    [arg3]="value3"
    [arg4]="value4"
>
<some-component>
```

#### 12. Каждый компонент должен иметь блок-обертку.

**Почему?** Потенциально может привести к проблемам верстки, если настроен какой-нибудь сдвиг по тегу, который повлияет на первый тег.

```html
<!-- плохо -->
<div>1</div>
<div>2</div>

<!-- хорошо -->
<div>
  <div>1</div>
  <div>2</div>
</div>
```

#### 13. В `Angular` для доступа к полям формы используется метод `form.get(‘controlName’)`.

#### 14. В шаблоне сперва указываются `html-атрибуты` , потом атрибуты `Angular` для настройки видимости, потом `@Input()`, потом `@Output()`.

**Почему?** Свойство `controls` используется для доступа к полям, с целью итеративных операций, например: генерация формы в цикле.

#### 15. Если создается сервис (компонент/класс) для постепенной замены старого сервиса, то называть его SomeEntityNewService.

    a. NewSomeEntityService – хороший вариант, но в каталоге файлов будет далеко располагаться от оригинального сервиса.

    b. SomeEntity2Service – использование цифр в наименовании не очень хорошая практика.

#### 16. Вынести код из `Pipe` функцию в `Utils`. Импортировать функцию в `Pipe` и в сервисы и компоненты при необходимости.

**Почему?** Отделяется логика `Angular` от логики `JS/TS`. Не требует провайдинга `Pipe` в компонент или сервис. Код становиться чище.

# Архитектура проекта

1. Делаем общий сервис, который хранит в себе начальную сущность/модифицированную модель, текущую модель, методы для работы с моделью. Методы для работы с бэком (загрузить, сохранить).
2. Загружаем сущность в сервис. Если работаем с сущностью, то сохраняем в поле, которое не редактируется. Если работаем с модифицированной моделью, то на основе загруженной сущности делаем модель и сохраняем в неизменяемое поле.
3. Для каждого компонента сущности делаем сервис, который ответственный за логику и работу с данными.
4. Если сущность простая (из одной формы; например запись из справочника), то делаем все в одном сервисе.
5. Если сущность состоит из нескольких подсущностей, то создается общий сервис для данных. Возможно отдельное вынесение сервиса для валидации подсущностей для различных состояний.
6. Главный компонент подписывается на модель, в остальные компоненты данные спускаются через `@Input()` или подписка на модель при необходимости.
7. Для изменения данных – дочерние компоненты обращаются к сервису и вызывают метод изменения модели.
8. Возможно выделение отдельного сервиса/сервисов под специфичные подзадачи (например, перемещение по статусам)
9. Сервисы провайдятся в компоненты или корень приложения.
10. `ModifyRequest` - класс, а не интерфейс. Заполняем данные через конструктор.

```ts
// инициализация при добавлении
this.modifyRequest = new ModifyRequestEntity()

// инициализация при редактировании
this.modifyRequest = new ModifyRequestEntity(entityFromResponse)
```
 
11. В компоненте получаем `modifyRequest` пишем его в `this.form.patchValue()`. В подписке на изменения формы проверяем, через `deepEqual`, налиличе изменениц изменения, то отправляем данные в "главный сервис".
12. Валидация простых сущностей (1 сущность – один компонент-форма) – можно делать валидацию на уровне формы компонента и отправлять флаг valid в глобальный сервис сущности.
13. Для составных сущностей (1 сущность – несколько компонент-форм) – сделать обработку валидации в отдельном сервисе валидации для сущности, в нем же разрешать проблемы с зависимостями данных одной формы от другой при валидации. Сервис-валидации будет отправлять сам флаг valid в главный сервис, а также будет возвращать коды/текстовки ошибок для компонентов (единым объектом или строками).

## Что позволит данная архитектура:

1. Единый источник истины – «главный сервис» сущности.
2. Компоненты почти полностью отвечают только за отрисовку, без логики.
3. Код компонентов будет минимален.
4. Логика будет отделена от представления. Позволит гораздо проще проводить редизайн.
5. Возможности использовать OnPush-стратегию – для снижения количества перерисовок.
6. Легче будет использовать библиотеки для стейт-менеджмента, или же сделать логирование самописной истории изменений для отладки.

# Порядок полей в файле

```ts
/* различные импорты */
import {Component, OnDestroy, OnInit, ViewChild} from '@angular/core';
import {Observable, Subject} from 'rxjs';

/* небольшие enum, interface, class, const и подобное, что не обязательно выносить в отдельный файл */
enum mode {
	create,
	edit,
	view
}

/* Подпись компонента, если есть возможность*/
/** SOME_COMPONENT Название компонента, если оно есть в постановке */
/** Также можно добавлять ссылку на постановку, если она одна */

/* Декоратор компонента */
/* Обязательно использовать selector, с ним легче вести отладку кода*/
@Component({
	selector: 'component-selector',
    templateUrl: './some-component.component.html',
    styleUrls: ['./some-component.component.scss'],
    providers: [SomeService]
})
export class SbaAgreementCardComponent implements OnInit, OnDestroy {
	/*Первыми идут ViewChild*/
    @ViewChild('table', {static: false}) table: TableComponent;
    @ViewChild('tableFilter', {static: false}) tableFilter: TableFilterComponent;

	/* INPUT - параметры компонента*/
	/* Сперва идут простые INPUT*/
	@INPUT() organization: Organization;
	...

	/* Через строку отделены INPUT, которые имеют get и set*/
	@INPUT() set viewMode(value: boolean) {
        this.innerViewMode = this.accountTabViewMode = value;
    }

    get viewMode(): boolean {
        return this.innerViewMode;
    }

	/* OUTPUT - параметры компонента*/
	@Output() onChange: EventEmitter<someModel> = new EventEmitter<someModel>();
    @Output() onValidation: EventEmitter<boolean> = new EventEmitter<boolean>();
	...

	/*Публичные поля компонента*/
    title: string = 'Заголовок компонента';
    showErrors = false;
    hasChanges = false;
    /*Сперва идут простые поля, в конце указываются поля, которые не помещаются в одну строку (объекты или несколько типов через "или")*/
    someMode = {
        field1: false,
        field2: false,
        field3: false,
    }
    ...

	/*Публичные readonly поля компонента*/
    readonly readonlyData = ReadonlyData;
	...

	/*Приватные поля компонента*/
    private onDestroy$ = new Subject();
    private dialogRef: DynamicDialogRef;
	...

    /*Приватные readonly поля компонента*/
	private readonly someField: '';

	/*Конструктор класса */
    constructor(
		/* сперва идут публичные аргументы*/
        readonly someServiceService: SomeServiceService,
		/* в конце идут приватные аргументы*/
        private readonly preloaderService: PreloaderService
    ) {}

    /*getter-ы*/
    get organizationNameControl(){
        ...
    }

    /*setter-ы*/
    set organizationNameControl(){
        ...
    }

	/*ngOnInit и  ngAfterViewInit - первые публичные методы компонента, после конструктора*/
    ngOnInit() {
    ...
    }

    ngAfterViewInit() {
    ...
    }

	/*Остальные публичные методы компонента*/

	edit(){
	...
	}

	save(){
	...
	}

	/*Последними публичными методами идут ngOnDestroy и canDeactivated*/
    ngOnDestroy(): void {
    ...
    }

	/*Все protected поля*/
    protected checkingValidation() {
    ...
    }

	/*Все публичные поля*/
    private checkingValidation() {
    ...
    }
}

```
