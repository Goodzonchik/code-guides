# Angular

1. Соглашения по именованию:

   1.1. Экземпляры сервисов называть также как и сервисы, только в camelCase
   someService = new SomeService();
   Поможет избежать путаницы в понимании того, с какой сущностью идет взаимодействие

   1.2. Для observable добавлять в конце `$`. Согласно неймингу ангуляра. Также поможет понимать, что есть observable, а что – нет.

2. Делать текстовый комментарий для каждого поля `@Input()`/`@Output()`

3. Если `@Input()` имеет getter и setter, то если там больше 3 строк, то стоит выносить его в функцию/метод

4. Делать комментарий с названием компонента по постановке и ссылкой на постановку

# Архитектура проекта

1. Делаем общий сервис, который хранит в себе начальную сущность/модифицированную модель, текущую модель, методы для работы с моделью. Методы для работы с бэком (загрузить, сохранить).
2. Загружаем сущность в сервис.
   a. Если работает с сущностью, то сохраняем в поле, которое не изменяемое
   b. Если работаем с модифицированной моделью, то на основе загруженной сущности делаем модель и сохраняем в неизменяемое поле
3. Для каждого компонента сущности делаем сервис, который отечественный за логику и работу с данными
4. Если сущность простая (из одной формы; например запись из справочника), то делаем все в одном сервисе.
5. Если сущность состоит из нескольких подсущностей, то создается общий сервис для данных. Возможно отдельное вынесение сервиса для валидации подсущностей для различных состояний.
6. Главный компонент подписывается на модель, в остальные компоненты данные спускаются через @Input().
7. Для изменения данных – дочерние компоненты обращаются к сервису и отправляют в него метод изменения модели.
8. Возможно выделение отдельного сервиса/сервисов под специфичные подзадачи (например, перемещение по статусам)
9. Сервисы провайдятся в компоненты или корень приложения.
10. ModifyRequest - класс, а не интерфейс. Заполняем данные через конструктор.
    a. При инициализации делаем так:
    this.modifyRequest = new ModifyRequestEntity() - для формирования пустой записи с информацией значений по умолчанию.
    b. передаём полученную с бэка запись
    this.modifyRequest = new ModifyRequestEntity(entityFromResponse)
11. В компоненте. Получаем modifyRequest пишем его в this.form.patchValue() И в подписке на изменения формы проверяем, через deepEqual, если есть изменения, то отправляем данные в главный сервис.
12. Валидация
    a. Для простых сущностей (1 сущность – один компонент-форма) – можно делать валидацию на уровне формы компонента и отправлять флаг valid в глобальный сервис сущности
    b. Для составных сущностей (1 сущность – несколько компонент-форм) – сделать обработку валидации в отдельном сервисе валидации для сущности, в нем же разрешать проблемы с зависимостями данных одной формы от другой при валидации. Сервис-валидации будет отправлять сам флаг valid в главный сервис, а также будет возвращать коды/текстовки ошибок для компонентов (единым объектом или строками).
13.

## Что позволит данная архитектура:

1. Единый источник истины – «главный сервис» сущности.
2. Компоненты почти полностью отвечают только за отрисовку, без логики
3. Код компонентов будет минимален
4. Логика будет отделена от представления. Позволит гораздо проще проводить редизайн.
5. Возможности использовать OnPush-стратегию – для снижения количества перерисовок
6.
